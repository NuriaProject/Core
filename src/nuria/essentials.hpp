/* Copyright (c) 2014, The Nuria Project
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *    1. The origin of this software must not be misrepresented; you must not
 *       claim that you wrote the original software. If you use this software
 *       in a product, an acknowledgment in the product documentation would be
 *       appreciated but is not required.
 *    2. Altered source versions must be plainly marked as such, and must not be
 *       misrepresented as being the original software.
 *    3. This notice may not be removed or altered from any source
 *       distribution.
 */

#ifndef NURIA_ESSENTIALS_HPP
#define NURIA_ESSENTIALS_HPP

#include "core_global.hpp"
#include <cstdint>

namespace Nuria {

/** \internal Helper for Nuria::jenkinsHash */
constexpr uint32_t jenkinsOne (uint32_t hash, const char *key, int len) {
	return (len < 1)
		? hash
		: jenkinsOne ((hash + *key + ((hash + *key) << 10)) ^
			      ((hash + *key + ((hash + *key) << 10)) >> 6),
			      key + 1, len - 1);
}

/**
 * \brief constexpr implementation of jenkins hashing algorithm.
 * 
 * This method will be evaluated by the compiler at compile-time, which is
 * useful when needing a simple hash of compile-time constants.
 * 
 * Used in Nuria::Debug for quick checks if a specific module shall not be
 * printed.
 * 
 */
constexpr uint32_t jenkinsHash (const char *key, size_t len) {
	return ((jenkinsOne (0, key, len) + (jenkinsOne (0, key, len) << 3)) ^
	        ((jenkinsOne (0, key, len) + (jenkinsOne (0, key, len) << 3)) >> 11)) +
	       (((jenkinsOne (0, key, len) + (jenkinsOne (0, key, len) << 3)) ^
		((jenkinsOne (0, key, len) + (jenkinsOne (0, key, len) << 3)) >> 11)) << 15);
}

}

/**
 * Taken from Q_DECLARE_METATYPE, with the difference being that this version
 * supports declaration of template types with multiple template arguments,
 * such as QMap<Key,T>. Please note that you should follow the C++03 style
 * of space indention in the argument, meaning that the spaces occur between
 * '>'. This is necessary as the type name itself is generated by the
 * preprocessor (Using the 'stringify' operation), thus, any extra spaces etc.
 * would end up in the type name, making the type impossible to find.
 */
#define NURIA_DECLARE_METATYPE(...)                                            \
    QT_BEGIN_NAMESPACE                                                         \
    template <>                                                                \
    struct QMetaTypeId< __VA_ARGS__ >                                          \
    {                                                                          \
        enum { Defined = 1 };                                                  \
        static int qt_metatype_id()                                            \
            {                                                                  \
                static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0); \
                if (const int id = metatype_id.loadAcquire())                  \
                    return id;                                                 \
                const int newId = qRegisterMetaType< __VA_ARGS__ >(#__VA_ARGS__, \
                              reinterpret_cast< __VA_ARGS__ *>(quintptr(-1))); \
                metatype_id.storeRelease(newId);                               \
                return newId;                                                  \
            }                                                                  \
    };                                                                         \
    QT_END_NAMESPACE

#endif // NURIA_ESSENTIALS_HPP
