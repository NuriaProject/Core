/* Copyright (c) 2014-2015, The Nuria Project
 * The NuriaProject Framework is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 * 
 * The NuriaProject Framework is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with The NuriaProject Framework.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef NURIA_ESSENTIALS_HPP
#define NURIA_ESSENTIALS_HPP

#include "core_global.hpp"
#include <cstdint>

namespace Nuria {

/** \internal Helper for Nuria::jenkinsHash */
constexpr uint32_t jenkinsOne (uint32_t hash, const char *key, int len) {
	return (len < 1)
		? hash
		: jenkinsOne ((hash + *key + ((hash + *key) << 10)) ^
			      ((hash + *key + ((hash + *key) << 10)) >> 6),
			      key + 1, len - 1);
}

/**
 * \brief constexpr implementation of jenkins hashing algorithm.
 * 
 * This method will be evaluated by the compiler at compile-time, which is
 * useful when needing a simple hash of compile-time constants.
 * 
 * Used in Nuria::Debug for quick checks if a specific module shall not be
 * printed.
 * 
 */
constexpr uint32_t jenkinsHash (const char *key, size_t len) {
	return ((jenkinsOne (0, key, len) + (jenkinsOne (0, key, len) << 3)) ^
	        ((jenkinsOne (0, key, len) + (jenkinsOne (0, key, len) << 3)) >> 11)) +
	       (((jenkinsOne (0, key, len) + (jenkinsOne (0, key, len) << 3)) ^
		((jenkinsOne (0, key, len) + (jenkinsOne (0, key, len) << 3)) >> 11)) << 15);
}

}

/**
 * Taken from Q_DECLARE_METATYPE, with the difference being that this version
 * supports declaration of template types with multiple template arguments,
 * such as QMap<Key,T>. Please note that you should follow the C++03 style
 * of space indention in the argument, meaning that the spaces occur between
 * '>'. This is necessary as the type name itself is generated by the
 * preprocessor (Using the 'stringify' operation), thus, any extra spaces etc.
 * would end up in the type name, making the type impossible to find.
 */
#define NURIA_DECLARE_METATYPE(...)                                            \
    QT_BEGIN_NAMESPACE                                                         \
    template <>                                                                \
    struct QMetaTypeId< __VA_ARGS__ >                                          \
    {                                                                          \
        enum { Defined = 1 };                                                  \
        static int qt_metatype_id()                                            \
            {                                                                  \
                static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0); \
                if (const int id = metatype_id.loadAcquire())                  \
                    return id;                                                 \
                const int newId = qRegisterMetaType< __VA_ARGS__ >(#__VA_ARGS__, \
                              reinterpret_cast< __VA_ARGS__ *>(quintptr(-1))); \
                metatype_id.storeRelease(newId);                               \
                return newId;                                                  \
            }                                                                  \
    };                                                                         \
    QT_END_NAMESPACE

#endif // NURIA_ESSENTIALS_HPP
