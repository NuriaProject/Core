<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Nuria Framework - Core: Nuria::Variant Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Nuria Framework - Core
   </div>
   <div id="projectbrief">Core module of the NuriaProject Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Nuria</b></li><li class="navelem"><a class="el" href="class_nuria_1_1_variant.html">Variant</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_nuria_1_1_variant-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Nuria::Variant Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_nuria_1_1_variant.html" title="The Variant class provides utilities for working with QVariants. Working with QVariants can be tediou...">Variant</a> class provides utilities for working with QVariants. Working with QVariants can be tedious if you have to work with them without knowing the structure of the data they hold. So, if you need to do convert a QVariant or want to compare them look no futher.  
 <a href="class_nuria_1_1_variant.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="variant_8hpp_source.html">variant.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant_1_1_iterator.html">Iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afcb9c646a47ab8b5a9e562e98cf578e8"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#afcb9c646a47ab8b5a9e562e98cf578e8">Comparison</a> )(const void *, const void *)</td></tr>
<tr class="separator:afcb9c646a47ab8b5a9e562e98cf578e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bda1f2c26e0e232f091dc9e125ddcf"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#af7bda1f2c26e0e232f091dc9e125ddcf">Conversion</a> )(const void *)</td></tr>
<tr class="separator:af7bda1f2c26e0e232f091dc9e125ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d79cccdddd3d32383803f8f581ff95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41d79cccdddd3d32383803f8f581ff95"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IteratorDtorFunc</b> )(void *)</td></tr>
<tr class="separator:a41d79cccdddd3d32383803f8f581ff95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c76af10ec3b64bc429342ef22e4636"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21c76af10ec3b64bc429342ef22e4636"></a>
typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><b>IteratorCopyFunc</b> )(void *)</td></tr>
<tr class="separator:a21c76af10ec3b64bc429342ef22e4636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfd58ff71042e82c3ea5ecb31356f41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacfd58ff71042e82c3ea5ecb31356f41"></a>
typedef QVariant(*&#160;</td><td class="memItemRight" valign="bottom"><b>IteratorValueFunc</b> )(void *, int)</td></tr>
<tr class="separator:aacfd58ff71042e82c3ea5ecb31356f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e78d3f2b33fa90de5b419987451381"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04e78d3f2b33fa90de5b419987451381"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IteratorIncFunc</b> )(void *)</td></tr>
<tr class="separator:a04e78d3f2b33fa90de5b419987451381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dd937c0b9e34bc10859068e717af38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4dd937c0b9e34bc10859068e717af38"></a>
typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><b>IteratorMoveFunc</b> )(void *, int)</td></tr>
<tr class="separator:ad4dd937c0b9e34bc10859068e717af38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1483e08e5f3c84fe65f4ac34cd6d1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e1483e08e5f3c84fe65f4ac34cd6d1f"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>IteratorDistanceFunc</b> )(void *, void *)</td></tr>
<tr class="separator:a2e1483e08e5f3c84fe65f4ac34cd6d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427bce4423ae7efc526fdda429f262e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a427bce4423ae7efc526fdda429f262e7"></a>
typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><b>IteratorStartEndFunc</b> )(void *)</td></tr>
<tr class="separator:a427bce4423ae7efc526fdda429f262e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a6317b16750eee73d9b19ccf43c8e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5a6317b16750eee73d9b19ccf43c8e8"></a>
typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><b>IteratorComparisonFunc</b> )(void *, void *)</td></tr>
<tr class="separator:ab5a6317b16750eee73d9b19ccf43c8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a2e18607d30afe356ea786c351fd8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0a2e18607d30afe356ea786c351fd8e"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>IteratorCountFunc</b> )(void *)</td></tr>
<tr class="separator:ab0a2e18607d30afe356ea786c351fd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d33429747ae212d43e5668924d9bab3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d33429747ae212d43e5668924d9bab3"></a>
typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><b>IteratorFindFunc</b> )(void *, const QVariant &amp;)</td></tr>
<tr class="separator:a9d33429747ae212d43e5668924d9bab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gacbb614f68b251386acef45082f535d9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacbb614f68b251386acef45082f535d9e"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal</b> (const QVariant &amp;left, const QVariant &amp;right)</td></tr>
<tr class="separator:gacbb614f68b251386acef45082f535d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga434ec53afd44c9f541ed5a8698f805b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga434ec53afd44c9f541ed5a8698f805b8"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>notEqual</b> (const QVariant &amp;left, const QVariant &amp;right)</td></tr>
<tr class="separator:ga434ec53afd44c9f541ed5a8698f805b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad665f40a6e71f25e1f35b528d5ff9c63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad665f40a6e71f25e1f35b528d5ff9c63"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>lessThan</b> (const QVariant &amp;left, const QVariant &amp;right)</td></tr>
<tr class="separator:gad665f40a6e71f25e1f35b528d5ff9c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga862647891184da84fff6e03c4979ba24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga862647891184da84fff6e03c4979ba24"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>greaterThan</b> (const QVariant &amp;left, const QVariant &amp;right)</td></tr>
<tr class="separator:ga862647891184da84fff6e03c4979ba24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada8e7d92cf0657e8fe09aec066354f89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gada8e7d92cf0657e8fe09aec066354f89"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>lessEqualThan</b> (const QVariant &amp;left, const QVariant &amp;right)</td></tr>
<tr class="separator:gada8e7d92cf0657e8fe09aec066354f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a92aa2aaeff47cf07d54e520c332fa3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3a92aa2aaeff47cf07d54e520c332fa3"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>greaterEqualThan</b> (const QVariant &amp;left, const QVariant &amp;right)</td></tr>
<tr class="separator:ga3a92aa2aaeff47cf07d54e520c332fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae980bf856f558303163182dca14f7dfa"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___comparison.html#gae980bf856f558303163182dca14f7dfa">canCompare</a> (const QVariant &amp;left, const QVariant &amp;right)</td></tr>
<tr class="separator:gae980bf856f558303163182dca14f7dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3036808944204dd13eef12541751dab8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___comparison.html#ga3036808944204dd13eef12541751dab8">canCompare</a> (const QVariant &amp;left, int rightType)</td></tr>
<tr class="separator:ga3036808944204dd13eef12541751dab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc8671760190cfaf849b0664fb804831"><td class="memTemplParams" colspan="2">template&lt;typename Right &gt; </td></tr>
<tr class="memitem:gabc8671760190cfaf849b0664fb804831"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___comparison.html#gabc8671760190cfaf849b0664fb804831">canCompare</a> (const QVariant &amp;left)</td></tr>
<tr class="separator:gabc8671760190cfaf849b0664fb804831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8da684cd30c07cb6a57b37b0a65d403"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:gac8da684cd30c07cb6a57b37b0a65d403"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___comparison.html#gac8da684cd30c07cb6a57b37b0a65d403">canCompare</a> ()</td></tr>
<tr class="separator:gac8da684cd30c07cb6a57b37b0a65d403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c0f248abb2048a0e8e4acff6d4be01b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___comparison.html#ga7c0f248abb2048a0e8e4acff6d4be01b">canCompare</a> (int leftType, int rightType)</td></tr>
<tr class="separator:ga7c0f248abb2048a0e8e4acff6d4be01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d8cea36f305dec2f37e24a2969c3a5f"><td class="memItemLeft" align="right" valign="top">static QVariant&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___convert.html#ga6d8cea36f305dec2f37e24a2969c3a5f">convert</a> (const QVariant &amp;variant, int type)</td></tr>
<tr class="separator:ga6d8cea36f305dec2f37e24a2969c3a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5635849d8b9be954f5f8a94dee12d090"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5635849d8b9be954f5f8a94dee12d090"><td class="memTemplItemLeft" align="right" valign="top">static QVariant&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___convert.html#ga5635849d8b9be954f5f8a94dee12d090">convert</a> (const QVariant &amp;variant)</td></tr>
<tr class="separator:ga5635849d8b9be954f5f8a94dee12d090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf80b2fb080814d8d1d65709341d6e359"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf80b2fb080814d8d1d65709341d6e359"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___convert.html#gaf80b2fb080814d8d1d65709341d6e359">canConvert</a> (const QVariant &amp;variant)</td></tr>
<tr class="separator:gaf80b2fb080814d8d1d65709341d6e359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff386c6ac8ab703c2a61f2b37251ec31"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___convert.html#gaff386c6ac8ab703c2a61f2b37251ec31">canConvert</a> (const QVariant &amp;variant, int toType)</td></tr>
<tr class="separator:gaff386c6ac8ab703c2a61f2b37251ec31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff3efbc2eb5296afee877fbd1947ee6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___convert.html#gafff3efbc2eb5296afee877fbd1947ee6">canConvert</a> (int fromType, int toType)</td></tr>
<tr class="separator:gafff3efbc2eb5296afee877fbd1947ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7edfbdc35697a9df4cb35d70e9f60e1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac7edfbdc35697a9df4cb35d70e9f60e1"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#ac7edfbdc35697a9df4cb35d70e9f60e1">toValue</a> (const QVariant &amp;variant)</td></tr>
<tr class="separator:ac7edfbdc35697a9df4cb35d70e9f60e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdeb4e790f3967ebf4bd8b39e0e231e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abdeb4e790f3967ebf4bd8b39e0e231e5"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#abdeb4e790f3967ebf4bd8b39e0e231e5">registerType</a> ()</td></tr>
<tr class="separator:abdeb4e790f3967ebf4bd8b39e0e231e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41210f824d10090472796acad7d0c9b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Right &gt; </td></tr>
<tr class="memitem:aa41210f824d10090472796acad7d0c9b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#aa41210f824d10090472796acad7d0c9b">registerType</a> ()</td></tr>
<tr class="separator:aa41210f824d10090472796acad7d0c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157dfb16f5e87ddae18af7078bd805b3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#a157dfb16f5e87ddae18af7078bd805b3">registerType</a> (int type, int rightType, <a class="el" href="class_nuria_1_1_variant.html#afcb9c646a47ab8b5a9e562e98cf578e8">Comparison</a> equal, <a class="el" href="class_nuria_1_1_variant.html#afcb9c646a47ab8b5a9e562e98cf578e8">Comparison</a> lessThan)</td></tr>
<tr class="separator:a157dfb16f5e87ddae18af7078bd805b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fa6f8a5027f8d22bd9065e50997f2a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#a58fa6f8a5027f8d22bd9065e50997f2a">registerType</a> (int type, int rightType, <a class="el" href="class_nuria_1_1_variant.html#afcb9c646a47ab8b5a9e562e98cf578e8">Comparison</a> equal, <a class="el" href="class_nuria_1_1_variant.html#afcb9c646a47ab8b5a9e562e98cf578e8">Comparison</a> notEqual, <a class="el" href="class_nuria_1_1_variant.html#afcb9c646a47ab8b5a9e562e98cf578e8">Comparison</a> less, <a class="el" href="class_nuria_1_1_variant.html#afcb9c646a47ab8b5a9e562e98cf578e8">Comparison</a> greater, <a class="el" href="class_nuria_1_1_variant.html#afcb9c646a47ab8b5a9e562e98cf578e8">Comparison</a> lessEqual, <a class="el" href="class_nuria_1_1_variant.html#afcb9c646a47ab8b5a9e562e98cf578e8">Comparison</a> greaterEqual)</td></tr>
<tr class="separator:a58fa6f8a5027f8d22bd9065e50997f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9f82a28e835c53a2e03765f20f7db4"><td class="memTemplParams" colspan="2">template&lt;typename From , typename To &gt; </td></tr>
<tr class="memitem:aee9f82a28e835c53a2e03765f20f7db4"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#aee9f82a28e835c53a2e03765f20f7db4">registerConversion</a> (To *(*func)(const From &amp;))</td></tr>
<tr class="separator:aee9f82a28e835c53a2e03765f20f7db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fd2396afa00dff50a1d0602a3accf4"><td class="memTemplParams" colspan="2">template&lt;typename From , typename To &gt; </td></tr>
<tr class="memitem:a72fd2396afa00dff50a1d0602a3accf4"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#a72fd2396afa00dff50a1d0602a3accf4">registerConversion</a> ()</td></tr>
<tr class="separator:a72fd2396afa00dff50a1d0602a3accf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed455f8e0caab52693030e9a7914a6d4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#aed455f8e0caab52693030e9a7914a6d4">registerConversion</a> (int from, int to, <a class="el" href="class_nuria_1_1_variant.html#af7bda1f2c26e0e232f091dc9e125ddcf">Conversion</a> func)</td></tr>
<tr class="separator:aed455f8e0caab52693030e9a7914a6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe72a0fd0b7c631feac841fd914a1fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7fe72a0fd0b7c631feac841fd914a1fd"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#a7fe72a0fd0b7c631feac841fd914a1fd">registerIterators</a> (typename T::mapped_type *a=(typename T::mapped_type *) 0)</td></tr>
<tr class="separator:a7fe72a0fd0b7c631feac841fd914a1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b5c794ce371ac8d26f0abc19c52689"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae0b5c794ce371ac8d26f0abc19c52689"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#ae0b5c794ce371ac8d26f0abc19c52689">registerIterators</a> (typename T::value_type *a=(typename T::value_type *) 0)</td></tr>
<tr class="separator:ae0b5c794ce371ac8d26f0abc19c52689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160e128009310b74e794bd0db721ad40"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nuria_1_1_variant_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#a160e128009310b74e794bd0db721ad40">begin</a> (QVariant &amp;variant)</td></tr>
<tr class="separator:a160e128009310b74e794bd0db721ad40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2c5bed44422067901265cd65fe113d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nuria_1_1_variant_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#acf2c5bed44422067901265cd65fe113d">end</a> (QVariant &amp;variant)</td></tr>
<tr class="separator:acf2c5bed44422067901265cd65fe113d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c50b51c35d61fb71a539fdaad60cf96"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_nuria_1_1_variant_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#a2c50b51c35d61fb71a539fdaad60cf96">find</a> (QVariant &amp;variant, QVariant ident)</td></tr>
<tr class="separator:a2c50b51c35d61fb71a539fdaad60cf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f9844f9822f7e6ebd1b96e5d793d04"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#ac8f9844f9822f7e6ebd1b96e5d793d04">itemCount</a> (const QVariant &amp;variant)</td></tr>
<tr class="separator:ac8f9844f9822f7e6ebd1b96e5d793d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454f9fee6deb40e0388f3030d5853c49"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#a454f9fee6deb40e0388f3030d5853c49">isList</a> (const QVariant &amp;variant)</td></tr>
<tr class="separator:a454f9fee6deb40e0388f3030d5853c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e454aa37ba17d66ae4d4071600590a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#af9e454aa37ba17d66ae4d4071600590a">isList</a> (int typeId)</td></tr>
<tr class="separator:af9e454aa37ba17d66ae4d4071600590a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d3dc2f30a0ef455f2b307375c5a5ff"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#a89d3dc2f30a0ef455f2b307375c5a5ff">isMap</a> (const QVariant &amp;variant)</td></tr>
<tr class="separator:a89d3dc2f30a0ef455f2b307375c5a5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab277706460d9075b86619012e0a5b6c8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#ab277706460d9075b86619012e0a5b6c8">isMap</a> (int typeId)</td></tr>
<tr class="separator:ab277706460d9075b86619012e0a5b6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8a10fd0476517e83de0be4273f4df8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#a7a8a10fd0476517e83de0be4273f4df8">isGeneric</a> (const QVariant &amp;variant)</td></tr>
<tr class="separator:a7a8a10fd0476517e83de0be4273f4df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a65553bb15d61f658a7b5a1e09b265"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#ad5a65553bb15d61f658a7b5a1e09b265">isGeneric</a> (int typeId)</td></tr>
<tr class="separator:ad5a65553bb15d61f658a7b5a1e09b265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc86716d1a38c953e42730fd6bc01ad6"><td class="memItemLeft" align="right" valign="top">static QVariantList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#afc86716d1a38c953e42730fd6bc01ad6">toList</a> (QVariant variant)</td></tr>
<tr class="separator:afc86716d1a38c953e42730fd6bc01ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84853b4e93d351a66555803a166ed6b"><td class="memItemLeft" align="right" valign="top">static QVariantMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#aa84853b4e93d351a66555803a166ed6b">toMap</a> (QVariant variant)</td></tr>
<tr class="separator:aa84853b4e93d351a66555803a166ed6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24cb6d31b27a72eca7fb0f1b98424d6"><td class="memTemplParams" colspan="2">template&lt;typename... Items&gt; </td></tr>
<tr class="memitem:aa24cb6d31b27a72eca7fb0f1b98424d6"><td class="memTemplItemLeft" align="right" valign="top">static QVariantList&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#aa24cb6d31b27a72eca7fb0f1b98424d6">buildList</a> (const Items &amp;...items)</td></tr>
<tr class="separator:aa24cb6d31b27a72eca7fb0f1b98424d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd28ea0460136806f47b3e0f069f0c4"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nuria_1_1_variant.html#accd28ea0460136806f47b3e0f069f0c4">stealPointer</a> (QVariant &amp;variant)</td></tr>
<tr class="separator:accd28ea0460136806f47b3e0f069f0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_nuria_1_1_variant.html" title="The Variant class provides utilities for working with QVariants. Working with QVariants can be tediou...">Variant</a> class provides utilities for working with QVariants. Working with QVariants can be tedious if you have to work with them without knowing the structure of the data they hold. So, if you need to do convert a QVariant or want to compare them look no futher. </p>
<dl class="section warning"><dt>Warning</dt><dd>Do not use types with this class which use virtual methods as this can lead to crashes. If you want to use a type like this, register the pointer-type instead.</dd></dl>
<dl class="section user"><dt>Comparisons</dt><dd><a class="el" href="class_nuria_1_1_variant.html" title="The Variant class provides utilities for working with QVariants. Working with QVariants can be tediou...">Variant</a> provides multiple ways to compare two QVariants. First, if you haven't defined <b>NURIA_NO_TEMPLATE_COMPARISON</b> you're able to simply compare a QVariant to any class you registered to the Qt meta system:  if (myQVariant &lt; currentIndex) { // ...</dd></dl>
<p>Another possibility is to use the comparison methods as provided by <a class="el" href="class_nuria_1_1_variant.html" title="The Variant class provides utilities for working with QVariants. Working with QVariants can be tediou...">Variant</a> like equal or lessThan:  if (Nuria::Variant::lessThan (myQVariant, currentIndex)) { // ...</p>
<p>To be able to compare QVariants you need to register your classes by using registerType. </p><dl class="section note"><dt>Note</dt><dd>All registered classes must overload operator==() and operator&lt;() correctly.</dd></dl>
<p>Comparisons are alyways 'smart'. If you try to compare two QVariants of non-comparable types, it will first try to convert the RHS QVariant to the type of the LHS QVariant. If this fails, it tries to convert the RHS to something the LHS can compare to. If this still fails, LHS is checked if it can be compared to QVariants. If yes these operators are used, if not <code>false</code> is returned. To check if two types are comparable use one of the many canCompare overloads.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___comparison.html#gae980bf856f558303163182dca14f7dfa">canCompare</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>A failed comparison always returns <code>false!</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The LHS won't be touched. All conversions are done to the RHS only.</dd></dl>
<dl class="section user"><dt>Conversions</dt><dd>Another feature that QVariant is lacking is the ability to convert a QVariant to or from a user type. This means you can register conversion functions which take type A and return a pointer to an instance of type B. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___convert.html#ga6d8cea36f305dec2f37e24a2969c3a5f">convert</a> <a class="el" href="group___convert.html#gaf80b2fb080814d8d1d65709341d6e359">canConvert</a> <a class="el" href="class_nuria_1_1_variant.html#aee9f82a28e835c53a2e03765f20f7db4">registerConversion</a></dd></dl>
<p>It is also possible to check beforehand if a certain conversion is possible at all using one of the various <a class="el" href="group___convert.html#gaf80b2fb080814d8d1d65709341d6e359">canConvert()</a> overloads:</p><ul>
<li>By using the template version  if (<a class="el" href="group___convert.html#gaf80b2fb080814d8d1d65709341d6e359">Nuria::Variant::canConvert&lt; QString &gt;</a> (myQVariant)) { // ...</li>
<li>By using the type id of to target type  if (<a class="el" href="group___convert.html#gaf80b2fb080814d8d1d65709341d6e359">Nuria::Variant::canConvert</a> (myQVariant, QMetaType::QString)) { // ...</li>
<li>By using the type id of both the source and target type  if (<a class="el" href="group___convert.html#gaf80b2fb080814d8d1d65709341d6e359">Nuria::Variant::canConvert</a> (QMetaType::Int, QMetaType::QString)) { // ...</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Custom conversions take precedence over the default Qt ones!</dd></dl>
<dl class="section user"><dt>Iterating over a variant</dt><dd>A variant can hold multiple items if it contains a QStringList or a QVariantList. Sometimes it would be neat if you could iterate over this list without knowing its exact type, right? This is where VARIANT_FOREACH comes in. This little macro works like Q_FOREACH, with the exception it always expects a QVariant instead of a container. VARIANT_FOREACH iterates over any iteratorable type. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_nuria_1_1_variant.html#a7fe72a0fd0b7c631feac841fd914a1fd">registerIterators</a></dd></dl>
<p>Example: </p><div class="fragment"><div class="line">QVariant a (<span class="stringliteral">&quot;Hello&quot;</span>), b (QStringList() &lt;&lt; <span class="stringliteral">&quot;One&quot;</span> &lt;&lt; <span class="stringliteral">&quot;Two&quot;</span> &lt;&lt; <span class="stringliteral">&quot;Three&quot;</span>);</div>
<div class="line"><span class="comment">// Outputs: &quot;Hello&quot;</span></div>
<div class="line">VARIANT_FOREACH(<span class="keyword">const</span> QVariant &amp;cur, a) qDebug() &lt;&lt; cur;</div>
<div class="line"></div>
<div class="line"><span class="comment">//Outputs: &quot;One&quot; &quot;Two&quot; &quot;Three&quot; (on a line of their own)</span></div>
<div class="line">VARIANT_FOREACH(const QVariant &amp;cur, b) qDebug() &lt;&lt; cur;</div>
</div><!-- fragment --><p>If you need more control though, there is <a class="el" href="class_nuria_1_1_variant_1_1_iterator.html">Variant::Iterator</a> for you. It works like all Qt STL-style iterators. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_nuria_1_1_variant.html#a160e128009310b74e794bd0db721ad40">begin</a> <a class="el" href="class_nuria_1_1_variant.html#acf2c5bed44422067901265cd65fe113d">end</a> <a class="el" href="class_nuria_1_1_variant_1_1_iterator.html">Iterator</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="afcb9c646a47ab8b5a9e562e98cf578e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* Nuria::Variant::Comparison)(const void *, const void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prototype of a comparison function. </p>

</div>
</div>
<a class="anchor" id="af7bda1f2c26e0e232f091dc9e125ddcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* Nuria::Variant::Conversion)(const void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prototype of a conversion function. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a160e128009310b74e794bd0db721ad40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_nuria_1_1_variant_1_1_iterator.html">Iterator</a> Nuria::Variant::begin </td>
          <td>(</td>
          <td class="paramtype">QVariant &amp;&#160;</td>
          <td class="paramname"><em>variant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the begin iterator of <em>variant</em>. If <em>variant</em> is <code>invalid</code>, the returned iterator will be equal to the end iterator. </p>

</div>
</div>
<a class="anchor" id="aa24cb6d31b27a72eca7fb0f1b98424d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Items&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static QVariantList Nuria::Variant::buildList </td>
          <td>(</td>
          <td class="paramtype">const Items &amp;...&#160;</td>
          <td class="paramname"><em>items</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Builds a QVariantList out of all arguments passed to the method. This does the same as  QVariantList () &lt;&lt; QVariant::fromValue (first) &lt;&lt; ... But it's easier and shorter to read and write.</p>
<dl class="section note"><dt>Note</dt><dd>This method implicitly converts passed arguments of type const char* to QString. You can disable this by defining NURIA_NO_CHAR_ARRAY_TO_QSTRING </dd></dl>

</div>
</div>
<a class="anchor" id="acf2c5bed44422067901265cd65fe113d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_nuria_1_1_variant_1_1_iterator.html">Iterator</a> Nuria::Variant::end </td>
          <td>(</td>
          <td class="paramtype">QVariant &amp;&#160;</td>
          <td class="paramname"><em>variant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the end iterator of <em>variant</em>. </p>

</div>
</div>
<a class="anchor" id="a2c50b51c35d61fb71a539fdaad60cf96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_nuria_1_1_variant_1_1_iterator.html">Iterator</a> Nuria::Variant::find </td>
          <td>(</td>
          <td class="paramtype">QVariant &amp;&#160;</td>
          <td class="paramname"><em>variant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVariant&#160;</td>
          <td class="paramname"><em>ident</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator pointing to the item with key <em>ident</em> if <em>variant</em> contains a map-like type. If <em>variant</em> contains a list-like type, it'll search for an item which matches <em>ident</em>. If <em>variant</em> is generic, the value will be matched to <em>ident</em>. Whatever check is done, if <em>ident</em> can't be found a <code>invalid</code> <a class="el" href="class_nuria_1_1_variant_1_1_iterator.html">Iterator</a> instance is returned. </p><dl class="section warning"><dt>Warning</dt><dd>This function does <b>not</b> work like its STL-style counterpart! </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Iterator::isValid </dd></dl>

</div>
</div>
<a class="anchor" id="a7a8a10fd0476517e83de0be4273f4df8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Nuria::Variant::isGeneric </td>
          <td>(</td>
          <td class="paramtype">const QVariant &amp;&#160;</td>
          <td class="paramname"><em>variant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if <em>variant</em> contains a generic type. A generic type is a type which isn't a map nor a list. </p>

</div>
</div>
<a class="anchor" id="ad5a65553bb15d61f658a7b5a1e09b265"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Nuria::Variant::isGeneric </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a454f9fee6deb40e0388f3030d5853c49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Nuria::Variant::isList </td>
          <td>(</td>
          <td class="paramtype">const QVariant &amp;&#160;</td>
          <td class="paramname"><em>variant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if <em>variant</em> contains a iterable list. </p><dl class="section note"><dt>Note</dt><dd>A list in the sense of: Doesn't have a key. </dd></dl>

</div>
</div>
<a class="anchor" id="af9e454aa37ba17d66ae4d4071600590a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Nuria::Variant::isList </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a89d3dc2f30a0ef455f2b307375c5a5ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Nuria::Variant::isMap </td>
          <td>(</td>
          <td class="paramtype">const QVariant &amp;&#160;</td>
          <td class="paramname"><em>variant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if <em>variant</em> contains a iterable map. </p>

</div>
</div>
<a class="anchor" id="ab277706460d9075b86619012e0a5b6c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Nuria::Variant::isMap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ac8f9844f9822f7e6ebd1b96e5d793d04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Nuria::Variant::itemCount </td>
          <td>(</td>
          <td class="paramtype">const QVariant &amp;&#160;</td>
          <td class="paramname"><em>variant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the item count in a QVariant. If <em>variant</em> contains a non-iterable type <code>1</code> is returned. If <em>variant</em> is <em>invalid</em> <code>0</code> is returned. If <em>variant</em> contains a iterable type the item count is returned. </p>

</div>
</div>
<a class="anchor" id="aee9f82a28e835c53a2e03765f20f7db4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename From , typename To &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Nuria::Variant::registerConversion </td>
          <td>(</td>
          <td class="paramtype">To *(*)(const From &amp;)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registers a possible conversion from type <em>From</em> to type <em>To</em>. This method takes a pointer to a conversion method. This method must be static and must take an instance of <em>const From &amp;</em> as only argument. The method must return a pointer to an instance of <em>To</em>. If conversion fails the function should return <code>0</code>. </p>

</div>
</div>
<a class="anchor" id="a72fd2396afa00dff50a1d0602a3accf4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename From , typename To &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Nuria::Variant::registerConversion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Registers a automatically generated conversion function, which can convert a QVariant containing a instance of <em>From</em> to a QVariant containing a instance of <em>To</em>. This is possible if <em>To</em> has a constructor which accepts a instance of <em>To</em>. Prototype:  From (const To &amp;); or  From (To); </p>

</div>
</div>
<a class="anchor" id="aed455f8e0caab52693030e9a7914a6d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Nuria::Variant::registerConversion </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_nuria_1_1_variant.html#af7bda1f2c26e0e232f091dc9e125ddcf">Conversion</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Registers a possible conversion from <em>from</em> to <em>to</em>. The semantics of <em>func</em> are the same. </p>

</div>
</div>
<a class="anchor" id="a7fe72a0fd0b7c631feac841fd914a1fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Nuria::Variant::registerIterators </td>
          <td>(</td>
          <td class="paramtype">typename T::mapped_type *&#160;</td>
          <td class="paramname"><em>a</em> = <code>(typename&#160;T::mapped_type&#160;*)0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registers a iteratorable type to the system so it can be used by <a class="el" href="class_nuria_1_1_variant_1_1_iterator.html">Variant::Iterator</a> and VARIANT_FOREACH. </p>

</div>
</div>
<a class="anchor" id="ae0b5c794ce371ac8d26f0abc19c52689"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Nuria::Variant::registerIterators </td>
          <td>(</td>
          <td class="paramtype">typename T::value_type *&#160;</td>
          <td class="paramname"><em>a</em> = <code>(typename&#160;T::value_type&#160;*)0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Overload for types which don't have keys (lists, vectors, ...) </p>

</div>
</div>
<a class="anchor" id="abdeb4e790f3967ebf4bd8b39e0e231e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Nuria::Variant::registerType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registers a class to the system. After this method has been is called it is possible to compare QVariants containing instances of this class. </p><dl class="section note"><dt>Note</dt><dd>It is safe to call this method multiple times on the same class. </dd>
<dd>
If you want to compare against plain QVariants see the overloads of this method.</dd></dl>
<p>A good place to do this would be for example the constructor of the specific class. </p>

</div>
</div>
<a class="anchor" id="aa41210f824d10090472796acad7d0c9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Right &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Nuria::Variant::registerType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Same as the other registerType method, except that you can specify the type you want to compare your type to </p>

</div>
</div>
<a class="anchor" id="a157dfb16f5e87ddae18af7078bd805b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Nuria::Variant::registerType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rightType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_nuria_1_1_variant.html#afcb9c646a47ab8b5a9e562e98cf578e8">Comparison</a>&#160;</td>
          <td class="paramname"><em>equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_nuria_1_1_variant.html#afcb9c646a47ab8b5a9e562e98cf578e8">Comparison</a>&#160;</td>
          <td class="paramname"><em>lessThan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Registers a class without using templates. If you have implementations of all comparison operators for this type use the other overload of this method. <em>type</em> is the usertype id as reported by the Qt meta system. </p>

</div>
</div>
<a class="anchor" id="a58fa6f8a5027f8d22bd9065e50997f2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Nuria::Variant::registerType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rightType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_nuria_1_1_variant.html#afcb9c646a47ab8b5a9e562e98cf578e8">Comparison</a>&#160;</td>
          <td class="paramname"><em>equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_nuria_1_1_variant.html#afcb9c646a47ab8b5a9e562e98cf578e8">Comparison</a>&#160;</td>
          <td class="paramname"><em>notEqual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_nuria_1_1_variant.html#afcb9c646a47ab8b5a9e562e98cf578e8">Comparison</a>&#160;</td>
          <td class="paramname"><em>less</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_nuria_1_1_variant.html#afcb9c646a47ab8b5a9e562e98cf578e8">Comparison</a>&#160;</td>
          <td class="paramname"><em>greater</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_nuria_1_1_variant.html#afcb9c646a47ab8b5a9e562e98cf578e8">Comparison</a>&#160;</td>
          <td class="paramname"><em>lessEqual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_nuria_1_1_variant.html#afcb9c646a47ab8b5a9e562e98cf578e8">Comparison</a>&#160;</td>
          <td class="paramname"><em>greaterEqual</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Registers a class without using templates. If you have implemented all comparison operators use this method. </p>

</div>
</div>
<a class="anchor" id="accd28ea0460136806f47b3e0f069f0c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* Nuria::Variant::stealPointer </td>
          <td>(</td>
          <td class="paramtype">QVariant &amp;&#160;</td>
          <td class="paramname"><em>variant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Steals the pointer from <em>variant</em> and returns it. Works only for pointer types, that is, <code>T*</code> but not T. If <em>variant</em> is invalid, <code>nullptr</code> is returned. After return, <em>variant</em> will be invalid if it contained a pointer.</p>
<dl class="section note"><dt>Note</dt><dd>Ownership of the returned pointer is transferred to the caller. </dd></dl>

</div>
</div>
<a class="anchor" id="afc86716d1a38c953e42730fd6bc01ad6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static QVariantList Nuria::Variant::toList </td>
          <td>(</td>
          <td class="paramtype">QVariant&#160;</td>
          <td class="paramname"><em>variant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to convert <em>variant</em> to a QVariantList.</p><ul>
<li>If <em>variant</em> is not a list nor a map, a list containing <em>variant</em> is returned.</li>
<li>If <em>variant</em> is a list, its contents are copied over.</li>
<li>If <em>variant</em> is a map, all values are copied to a list.</li>
<li>If <em>variant</em> is <em>invalid</em>, an empty QVariantList is returned. </li>
</ul>

</div>
</div>
<a class="anchor" id="aa84853b4e93d351a66555803a166ed6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static QVariantMap Nuria::Variant::toMap </td>
          <td>(</td>
          <td class="paramtype">QVariant&#160;</td>
          <td class="paramname"><em>variant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to convert <em>variant</em> to a QVariantMap. This is only successful if:</p><ul>
<li><em>variant</em> contains a map of some type.</li>
<li>The key-type of the map can be converted to a QString.</li>
</ul>
<p>If one of these rules fail, an empty QVariantMap is returned. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_nuria_1_1_variant.html#a89d3dc2f30a0ef455f2b307375c5a5ff">isMap</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac7edfbdc35697a9df4cb35d70e9f60e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T Nuria::Variant::toValue </td>
          <td>(</td>
          <td class="paramtype">const QVariant &amp;&#160;</td>
          <td class="paramname"><em>variant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as QVariant::value, but this method tries to convert using the convert method instead. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="variant_8hpp_source.html">variant.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 27 2014 18:18:31 for Nuria Framework - Core by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
